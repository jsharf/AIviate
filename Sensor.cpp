#include "Sensor.h"

// Helps debugging with sensor structs
std::ostream& operator<<(std::ostream &out, sensorf &rhs)
{
    out << "SENSORF: \n{\n\t ax: " \
    << rhs.ax << "\n\t ay: " << rhs.ay << "\n\t az: " << rhs.az \
    << "\n\t gx: " << rhs.gx << "\n\t gy: " << rhs.gy << "\n\t gz: " << rhs.gz \
    << "\n\t mx: " << rhs.mx << "\n\t my: " << rhs.my << "\n\t mz: " << rhs.mz \
    << "\n\t altitude: " << rhs.altitude \
    << "\n}" << std::endl;
    return out;
}

void sensor_to_float(const sensor &a, sensor &f)
{
    f.mx = (float) a.mx;
    f.my = (float) a.my;
    f.mz = (float) a.mz;
    f.gx = (float) a.gx;
    f.gy = (float) a.gy;
    f.gz = (float) a.gz;
    f.ax = (float) a.ax;
    f.ay = (float) a.ay;
    f.az = (float) a.az;
    f.altitude = (float) a.altitude;
}

void sensorf_to_planestate(const sensorf &data, PlaneState p, float dt)
{
    static float k_accel = 0.01, \
                 k_gyro = 0.0003, \
                 k_r = 0.01; // Kalman filter constants
    // Create kalman filters to clean noisy sensor data
    static KalmanFilter filterXY(k_accel, k_gyro, k_r);
    static KalmanFilter filterYZ(k_accel, k_gyro, k_r);
    static KalmanFilter filterXZ(k_accel, k_gyro, k_r);
    // Convert acceleromter data to angles
    float angleXY = atan2(data.ay, data.ax);
    float angleYZ = atan2(data.az, data.ay);
    float andleXZ = atan2(data.az, data.ax);
    // Filter the angles
    angleXY = filterXY.calculate(angleXY, data.gz, dt);
    angleYZ = filterYZ.calculate(angleYZ, data.gx, dt);
    angleXZ = filterXZ.calculate(angleXZ, -data.gy, dt);
    // Convert the filtered angles to a vector
    float mag = sqrt(pow(data.ax,2) + pow(data.ay,2) + pow(data.az,2));
    // a1, a2, and a3 are the components of the gravity vector
    // generated by the euler angles
    Vector3d a1 = Vector3d::i.rotate(-angleXZ, Vector3d::j);
    Vector3d a2 = Vector3d::j.rotate(angleYZ, Vector3d::i);
    Vector3d a3 = Vector3d::i.rotate(angleXY, Vector3d::k);
    // Gravity vector = a1 + a2 + a3
    Vector3d gvector = a1 + a2 + a3;
    // Create a quaternion which rotates Vector3d::i to the gravity vector
    Quaternion attitude = Vector3d::i.quaternionTo(gvector);
    p.orientation = attitude;
}
